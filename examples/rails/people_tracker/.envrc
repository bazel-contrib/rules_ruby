# NOTE: This file was written to work with bash and zsh. It uses features like
# arrays which POSIX does not support.

source_up .envrc

module_bazel="$(find_up "MODULE.bazel")"
wksp_root_dir="$(dirname "${module_bazel}")"

# MARK - bazel_env Tools

# Add binaries and toolchains defined in //people_tracker:bazel_env.
bazel_env_dir="${wksp_root_dir}/bazel-out/bazel_env-opt/bin/people_tracker/bazel_env/bin"
watch_file "${bazel_env_dir}"
PATH_add "${bazel_env_dir}"
if [ ! -d "${bazel_env_dir}" ]; then
  log_error "ERROR[bazel_env.bzl]: Run 'bazel run //people_tracker:all_bazel_env' to" \
    "regenerate ${bazel_env_dir} and its parent envrcs."
fi

# MARK - Ruby Gems

# We configure the environment to use the Gemfile in this directory
# (BUNDLE_GEMFILE) and the Gems installed by Bazel (BUNDLE_PATH).
bundle_repo_name="people_tracker_bundle"

BUNDLE_GEMFILE="$(expand_path Gemfile)"
export BUNDLE_GEMFILE

# Look for the bundle path, if we see the convenience symlinks at the root of
# the Bazel workspace. We want to avoid running long-running commands (e.g.
# cquery) if the workspace has not been built. This is not a perfect test but
# should be good enough for most situations.
if [[ -L "${wksp_root_dir}/bazel-out" ]]; then
  bundle_files=()
  while IFS=$'\n' read -r line; do bundle_files+=("$line"); done < <(
    bazel cquery "@${bundle_repo_name}" --output files 2>/dev/null
  )
  for file in "${bundle_files[@]}"; do
    if [[ "${file}" =~ vendor/bundle$ ]]; then
      export BUNDLE_PATH="${wksp_root_dir}/${file}"
      break
    fi
  done
fi
if [[ -z "${BUNDLE_PATH:-}" ]] || [[ ! -e "${BUNDLE_PATH}" ]]; then
  log_error "ERROR[bazel_env.bzl]: Run 'bazel run //people_tracker:all_bazel_env' to" \
    "install the gems for this Ruby project."
fi
