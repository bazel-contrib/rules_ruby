"Implementation details for rb_binary"

load("@bazel_skylib//lib:paths.bzl", "paths")
load("@bazel_skylib//rules:common_settings.bzl", "BuildSettingInfo")
load("//ruby/private:library.bzl", LIBRARY_ATTRS = "ATTRS")
load(
    "//ruby/private:providers.bzl",
    "BundlerInfo",
    "GemBytecodeInfo",
    "RubyBytecodeInfo",
    "RubyFilesInfo",
    "get_bundle_env",
    "get_transitive_data",
    "get_transitive_deps",
    "get_transitive_runfiles",
    "get_transitive_srcs",
)
load(
    "//ruby/private:utils.bzl",
    "BASH_RLOCATION_FUNCTION",
    "BATCH_RLOCATION_FUNCTION",
    _convert_env_to_script = "convert_env_to_script",
    _is_windows = "is_windows",
    _normalize_path = "normalize_path",
    _to_rlocation_path = "to_rlocation_path",
)

_JDK_TOOLCHAIN = "@bazel_tools//tools/jdk:runtime_toolchain_type"

ATTRS = {
    "main": attr.label(
        executable = True,
        allow_files = True,
        cfg = "exec",
        doc = """
Ruby script to run. It may also be a binary stub generated by Bundler.
If omitted, it defaults to the Ruby interpreter.

Use a built-in `args` attribute to pass extra arguments to the script.
        """,
    ),
    "env": attr.string_dict(
        doc = """
Environment variables to use during execution.

Supports `$(location)` expansion for targets from `srcs`, `data` and `deps`.
""",
    ),
    "env_inherit": attr.string_list(
        doc = """\
List of environment variable names to be inherited by the test runner.\
""",
    ),
    "ruby": attr.label(
        doc = "Override Ruby toolchain to use when running the script.",
        providers = [platform_common.ToolchainInfo],
    ),
    "_binary_cmd_tpl": attr.label(
        allow_single_file = True,
        default = "@rules_ruby//ruby/private/binary:binary.cmd.tpl",
    ),
    "_binary_sh_tpl": attr.label(
        allow_single_file = True,
        default = "@rules_ruby//ruby/private/binary:binary.sh.tpl",
    ),
    "_runfiles_library": attr.label(
        default = "@bazel_tools//tools/bash/runfiles",
    ),
    "_windows_constraint": attr.label(
        default = "@platforms//os:windows",
    ),
    "_compile_bytecode": attr.label(
        default = "@rules_ruby//ruby:compile_bytecode",
    ),
    "_setup": attr.label(
        allow_files = True,
        default = "@rules_ruby//ruby/runtime:setup",
    ),
    "_merge_packs_script": attr.label(
        allow_single_file = True,
        default = "@rules_ruby//ruby/private/binary:merge_packs.rb",
    ),
    "_pack_bytecode_script": attr.label(
        allow_single_file = True,
        default = "@rules_ruby//ruby/private/bundle_install:pack_bytecode.rb",
    ),
}

# buildifier: disable=function-docstring
def generate_rb_binary_script(
        ctx,
        binary,
        bundler = False,
        args = [],
        env = {},
        java_bin = "",
        pack_path = ""):
    toolchain = ctx.toolchains["@rules_ruby//ruby:toolchain_type"]
    if ctx.attr.ruby != None:
        toolchain = ctx.attr.ruby[platform_common.ToolchainInfo]

    binary_path = ""
    locate_binary_in_runfiles = ""
    if binary and binary != toolchain.ruby:
        binary_path = binary.short_path

        # Runfiles library for Windows does not support generated directories,
        # so for now we skip locating the binary in runfiles. This only prevents
        # running binary scripts directly and should not affect normal
        # `bazel run`.
        # See BATCH_RLOCATION_FUNCTION comments for more details.
        if binary_path.startswith("../") and not _is_windows(ctx):
            binary_path = _to_rlocation_path(binary)
            locate_binary_in_runfiles = "true"
        else:
            binary_path = _normalize_path(ctx, binary_path)

    environment = {}
    environment.update(env)
    for k, v in environment.items():
        environment[k] = ctx.expand_location(
            v,
            ctx.attr.srcs + ctx.attr.data + ctx.attr.deps,
        )

    if _is_windows(ctx):
        rlocation_function = BATCH_RLOCATION_FUNCTION
        script = ctx.actions.declare_file("{}.cmd".format(ctx.label.name))
        template = ctx.file._binary_cmd_tpl
    else:
        rlocation_function = BASH_RLOCATION_FUNCTION
        script = ctx.actions.declare_file("{}.sh".format(ctx.label.name))
        template = ctx.file._binary_sh_tpl

    if bundler:
        bundler_command = "bundle exec"
    else:
        bundler_command = ""

    args = " ".join(args)
    args = ctx.expand_location(
        args,
        ctx.attr.srcs + ctx.attr.data + ctx.attr.deps,
    )

    ctx.actions.expand_template(
        template = template,
        output = script,
        is_executable = True,
        substitutions = {
            "{args}": args,
            "{binary}": binary_path,
            "{env}": _convert_env_to_script(ctx, environment),
            "{bundler_command}": bundler_command,
            "{ruby}": _to_rlocation_path(toolchain.ruby),
            "{ruby_binary_name}": toolchain.ruby.basename,
            "{java_bin}": java_bin,
            "{rlocation_function}": rlocation_function,
            "{locate_binary_in_runfiles}": locate_binary_in_runfiles,
            "{pack_path}": pack_path,
            "{rules_ruby_setup}": _to_rlocation_path(_get_setup_file(ctx)),
            "{bazel_workspace}": ctx.workspace_name,
        },
    )

    return script

def _get_setup_file(ctx):
    for file in ctx.files._setup:
        # This is a bit unholy, but avoids adding more targets or updating
        # the providers to expose the direct src files for an rb_library target.
        if file.basename == "setup.rb":
            return file
    fail("Expected to find `setup.rb` from _setup attribute.")

def _new_pack_info(file = None, path = "", bytecode_files = []):
    return struct(
        file = file,
        path = path,
        bytecode_files = bytecode_files,
    )

def _write_bytecode_pack_file(
        ctx,
        transitive_deps,
        gem_pack_file = None):
    if not ctx.attr._compile_bytecode[BuildSettingInfo].value:
        return _new_pack_info()

    # Collect all bytecode mappings from dependencies (app bytecode)
    all_mappings = {}
    for dep in transitive_deps.to_list():
        if RubyBytecodeInfo in dep:
            all_mappings.update(dep[RubyBytecodeInfo].transitive_mappings)

    # If no app mappings and no gem pack, return empty
    if len(all_mappings) == 0 and not gem_pack_file:
        return _new_pack_info()

    toolchain = ctx.toolchains["@rules_ruby//ruby:toolchain_type"]

    # Collect bytecode files from app mappings
    bytecode_files = list(all_mappings.values())

    # If we have app bytecode, create an app pack first
    app_pack_file = None
    if len(all_mappings) > 0:
        app_pack_file = ctx.actions.declare_file(
            "{}_app_bytecode.pack".format(ctx.label.name),
        )

        # Create app pack using a simple script that reads the bytecode files
        # and writes them to a pack
        app_pack_script = ctx.actions.declare_file(
            "{}_create_app_pack.rb".format(ctx.label.name),
        )

        # Generate script content to create app pack
        script_lines = [
            "#!/usr/bin/env ruby",
            "# frozen_string_literal: true",
            "",
            "require_relative '../../bundle_install/pack_bytecode'",
            "",
            "packer = BytecodePacker.new(ARGV[0])",
        ]
        for source_path, bytecode_file in all_mappings.items():
            script_lines.append("packer.add({}, File.binread(ARGV[{}]))".format(
                repr(source_path),
                len(script_lines) - 5,  # Calculate argument index
            ))
        script_lines.append("packer.write")

        # Actually, this approach is complex. Let's simplify:
        # If we have both app and gem bytecode, merge them
        # If only gem bytecode, use it directly
        # If only app bytecode, create a pack from the files

        # For now, let's use a simpler approach: create a Ruby script that
        # reads bytecode files and creates a pack

        # Simplified: Create pack script inline
        pack_entries = []
        for source_path, bytecode_file in all_mappings.items():
            pack_entries.append((source_path, bytecode_file))

        # Inline the BytecodePacker class to make the script self-contained
        script_content = """#!/usr/bin/env ruby
# frozen_string_literal: true

class BytecodePacker
  MAGIC = "RRBC"
  VERSION = 1
  HEADER_SIZE = 32

  def initialize(output_path)
    @output_path = output_path
    @entries = {}
  end

  def add(path, bytecode)
    @entries[path] = bytecode
  end

  def write
    File.open(@output_path, "wb") do |f|
      f.write("\\0" * HEADER_SIZE)
      index = {}
      @entries.each do |path, bytecode|
        offset = f.pos
        f.write(bytecode)
        index[path] = [offset, bytecode.bytesize]
      end
      index_offset = f.pos
      index_data = Marshal.dump(index)
      f.write(index_data)
      index_size = index_data.bytesize
      f.seek(0)
      f.write(MAGIC)
      f.write([VERSION].pack("L<"))
      f.write([index_offset].pack("Q<"))
      f.write([index_size].pack("Q<"))
    end
  end
end

packer = BytecodePacker.new(ARGV[0])
"""
        arg_idx = 1
        for source_path, _ in pack_entries:
            script_content += "packer.add({}, File.binread(ARGV[{}]))\n".format(
                repr(source_path),
                arg_idx,
            )
            arg_idx += 1
        script_content += "packer.write\n"

        ctx.actions.write(
            output = app_pack_script,
            content = script_content,
        )

        # Build arguments list: output_path, then all bytecode file paths
        args = [app_pack_file.path]
        for _, bytecode_file in pack_entries:
            args.append(bytecode_file.path)

        ctx.actions.run(
            executable = toolchain.ruby,
            arguments = [app_pack_script.path] + args,
            inputs = [app_pack_script] + bytecode_files,
            outputs = [app_pack_file],
            mnemonic = "CreateAppBytecodePack",
            progress_message = "Creating app bytecode pack for %{label}",
        )

    # Determine final pack file
    if app_pack_file and gem_pack_file:
        # Merge both packs
        merged_pack_file = ctx.actions.declare_file(
            "{}_bytecode.pack".format(ctx.label.name),
        )

        ctx.actions.run(
            executable = toolchain.ruby,
            arguments = [
                ctx.file._merge_packs_script.path,
                merged_pack_file.path,
                gem_pack_file.path,
                app_pack_file.path,
            ],
            inputs = [
                gem_pack_file,
                app_pack_file,
                ctx.file._merge_packs_script,
                ctx.file._pack_bytecode_script,
            ],
            outputs = [merged_pack_file],
            mnemonic = "MergeBytecodePacks",
            progress_message = "Merging bytecode packs for %{label}",
        )

        final_pack_file = merged_pack_file
    elif gem_pack_file:
        final_pack_file = gem_pack_file
    else:
        final_pack_file = app_pack_file

    pack_path = paths.join(
        ctx.workspace_name,
        _to_rlocation_path(final_pack_file),
    )
    return _new_pack_info(
        file = final_pack_file,
        path = pack_path,
        bytecode_files = bytecode_files,
    )

# buildifier: disable=function-docstring
def rb_binary_impl(ctx):
    bundler = False
    bundler_srcs = []
    env = {}
    java_bin = ""

    # TODO: avoid expanding the depset to a list, it may be expensive in a
    # large graph
    transitive_data = get_transitive_data(ctx.files.data, ctx.attr.deps)
    transitive_deps = get_transitive_deps(ctx.attr.deps)
    transitive_srcs = get_transitive_srcs(ctx.files.srcs, ctx.attr.deps)

    transitive_deps = depset([ctx.attr._setup], transitive = [transitive_deps])

    ruby_toolchain = ctx.toolchains["@rules_ruby//ruby:toolchain_type"]
    if ctx.attr.ruby != None:
        ruby_toolchain = ctx.attr.ruby[platform_common.ToolchainInfo]
    tools = list(ruby_toolchain.files)

    if ruby_toolchain.version.startswith("jruby"):
        java_toolchain = ctx.toolchains[_JDK_TOOLCHAIN]
        tools.extend(java_toolchain.java_runtime.files.to_list())
        java_bin = java_toolchain.java_runtime.java_executable_runfiles_path[3:]

    gem_pack_file = None
    compile_bytecode = ctx.attr._compile_bytecode[BuildSettingInfo].value
    for dep in transitive_deps.to_list():
        # TODO: Remove workspace name check together with `rb_bundle()`
        if dep.label.workspace_name.endswith("bundle"):
            bundler = True

        if BundlerInfo in dep:
            info = dep[BundlerInfo]
            bundler_srcs.extend([info.gemfile, info.bin, info.path])
            bundler = True

            # See https://bundler.io/v2.5/man/bundle-config.1.html for
            # confiugration keys.
            env.update({
                "BUNDLE_GEMFILE": _to_rlocation_path(info.gemfile),
                "BUNDLE_PATH": _to_rlocation_path(info.path),
            })

            # Check for gem bytecode via GemBytecodeInfo provider
            if compile_bytecode and GemBytecodeInfo in dep:
                gem_pack_file = dep[GemBytecodeInfo].pack_file

    if len(bundler_srcs) > 0:
        transitive_srcs = depset(bundler_srcs, transitive = [transitive_srcs])

    # Bytecode compilation support (merges gem pack if present)
    pack = _write_bytecode_pack_file(ctx, transitive_deps, gem_pack_file)

    bundle_env = get_bundle_env(ctx.attr.env, ctx.attr.deps)
    env.update(bundle_env)
    env.update(ruby_toolchain.env)
    env.update(ctx.attr.env)

    # Add bytecode files and pack to runfiles
    # Gem bytecode files are automatically included via DefaultInfo propagation
    runfiles_files = tools + pack.bytecode_files
    if pack.file:
        runfiles_files.append(pack.file)

    runfiles = ctx.runfiles(
        runfiles_files,
        transitive_files = depset(
            transitive = [transitive_srcs, transitive_data],
        ),
    )
    runfiles = get_transitive_runfiles(
        runfiles,
        ctx.attr.srcs,
        ctx.attr.deps,
        ctx.attr.data,
        ctx.attr._runfiles_library,
        ctx.attr._setup,
    )

    # Propagate executable from source rb_binary() targets.
    executable = ctx.executable.main
    if ctx.attr.main and RubyFilesInfo in ctx.attr.main and \
       ctx.attr.main[RubyFilesInfo].binary:
        executable = ctx.attr.main[RubyFilesInfo].binary

    script = generate_rb_binary_script(
        ctx,
        executable,
        bundler = bundler,
        env = env,
        java_bin = java_bin,
        pack_path = pack.path,
    )

    return [
        DefaultInfo(
            executable = script,
            files = depset(
                transitive = [
                    transitive_srcs,
                    depset(tools, transitive = [transitive_data]),
                ],
            ),
            runfiles = runfiles,
        ),
        RubyFilesInfo(
            binary = executable,
            transitive_data = depset(tools, transitive = [transitive_data]),
            transitive_deps = transitive_deps,
            transitive_srcs = transitive_srcs,
            bundle_env = bundle_env,
        ),
        RunEnvironmentInfo(
            environment = env,
            inherited_environment = ctx.attr.env_inherit,
        ),
    ]

rb_binary = rule(
    implementation = rb_binary_impl,
    executable = True,
    attrs = dict(
        ATTRS,
        srcs = LIBRARY_ATTRS["srcs"],
        data = LIBRARY_ATTRS["data"],
        deps = LIBRARY_ATTRS["deps"],
    ),
    toolchains = [
        "@rules_ruby//ruby:toolchain_type",
        "@bazel_tools//tools/jdk:runtime_toolchain_type",
    ],
    doc = """
Runs a Ruby binary.

Suppose you have the following Ruby gem, where `rb_library()` is used
in `BUILD` files to define the packages for the gem.

```output
|-- BUILD
|-- Gemfile
|-- WORKSPACE
|-- gem.gemspec
`-- lib
    |-- BUILD
    |-- gem
    |   |-- BUILD
    |   |-- add.rb
    |   |-- subtract.rb
    |   `-- version.rb
    `-- gem.rb
```

One of the files can be run as a Ruby script:

`lib/gem/version.rb`:
```ruby
module GEM
  VERSION = '0.1.0'
end

puts "Version is: #{GEM::VERSION}" if __FILE__ == $PROGRAM_NAME
```

You can run this script by defining a target:

`lib/gem/BUILD`:
```bazel
load("@rules_ruby//ruby:defs.bzl", "rb_binary", "rb_library")

rb_library(
    name = "version",
    srcs = ["version.rb"],
)

rb_binary(
    name = "print-version",
    args = ["lib/gem/version.rb"],
    deps = [":version"],
)
```

```output
$ bazel run lib/gem:print-version
...
Version is: 0.1.0
```

You can also run general purpose Ruby scripts that rely on a Ruby interpreter in PATH:

`lib/gem/add.rb`:
```ruby
#!/usr/bin/env ruby

a, b = *ARGV
puts Integer(a) + Integer(b)
```

`lib/gem/BUILD`:
```bazel
load("@rules_ruby//ruby:defs.bzl", "rb_binary", "rb_library")

rb_library(
    name = "add",
    srcs = ["add.rb"],
)

rb_binary(
    name = "add-numbers",
    main = "add.rb",
    deps = [":add"],
)
```

```output
$ bazel run lib/gem:add-numbers 1 2
...
3
```

You can also run a Ruby binary script available in Gemfile dependencies,
by passing `bin` argument with a path to a Bundler binary stub:

`BUILD`:
```bazel
load("@rules_ruby//ruby:defs.bzl", "rb_binary")

package(default_visibility = ["//:__subpackages__"])

rb_binary(
    name = "rake",
    main = "@bundle//bin:rake",
    deps = [
        "//lib:gem",
        "@bundle",
    ],
)
```

```output
$ bazel run :rake -- --version
...
rake, version 13.1.0
```
    """,
)
